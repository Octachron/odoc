\section{Module \ocamlinlinecode{Type}}\label{package-test+u+package+++ml-module-Type}%
\label{package-test+u+package+++ml-module-Type-type-abstract}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 abstract}\begin{ocamlindent}Some \emph{documentation}.\end{ocamlindent}%
\medbreak
\label{package-test+u+package+++ml-module-Type-type-alias}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 alias = int}\\
\label{package-test+u+package+++ml-module-Type-type-private+u+}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 private\_\allowbreak{} = \begin{keyword}private\end{keyword}
 int}\\
\label{package-test+u+package+++ml-module-Type-type-constructor}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 'a constructor = \begin{type-var}'a\end{type-var}
}\\
\label{package-test+u+package+++ml-module-Type-type-arrow}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 arrow = int $\rightarrow$ int}\\
\label{package-test+u+package+++ml-module-Type-type-higher+u+order}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 higher\_\allowbreak{}order = (int $\rightarrow$ int) $\rightarrow$ int}\\
\label{package-test+u+package+++ml-module-Type-type-labeled}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 labeled = l:int $\rightarrow$ int}\\
\label{package-test+u+package+++ml-module-Type-type-optional}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 optional = ?l:int $\rightarrow$ int}\\
\label{package-test+u+package+++ml-module-Type-type-labeled+u+higher+u+order}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 labeled\_\allowbreak{}higher\_\allowbreak{}order = (l:int $\rightarrow$ int) $\rightarrow$ (?l:int $\rightarrow$ int) $\rightarrow$ int}\\
\label{package-test+u+package+++ml-module-Type-type-pair}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 pair = int * int}\\
\label{package-test+u+package+++ml-module-Type-type-parens+u+dropped}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 parens\_\allowbreak{}dropped = int * int}\\
\label{package-test+u+package+++ml-module-Type-type-triple}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 triple = int * int * int}\\
\label{package-test+u+package+++ml-module-Type-type-nested+u+pair}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 nested\_\allowbreak{}pair = (int * int) * int}\\
\label{package-test+u+package+++ml-module-Type-type-instance}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 instance = int \hyperref[package-test+u+package+++ml-module-Type-type-constructor]{\ocamlinlinecode{constructor}}}\\
\label{package-test+u+package+++ml-module-Type-type-variant+u+e}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 variant\_\allowbreak{}e = \{}{\setlength{\LTpre}{0pt}\setlength{\LTpost}{0pt}\begin{ocamllongtable}[l]{p{1.000\textwidth}}\ocamlinlinecode{a : int;\allowbreak{}}\label{package-test+u+package+++ml-module-Type-type-variant+u+e.a}\\
\end{ocamllongtable}%
}\ocamlcodefragment{\}}\\
\label{package-test+u+package+++ml-module-Type-type-variant}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 variant = }{\setlength{\LTpre}{0pt}\setlength{\LTpost}{0pt}\begin{ocamllongtable}[l]{p{0.500\textwidth}p{0.500\textwidth}}\ocamlcodefragment{| \begin{constructor}A\end{constructor}
}\label{package-test+u+package+++ml-module-Type-type-variant.A}& \\
\ocamlcodefragment{| \begin{constructor}B\end{constructor}
 \begin{keyword}of\end{keyword}
 int}\label{package-test+u+package+++ml-module-Type-type-variant.B}& \\
\ocamlcodefragment{| \begin{constructor}C\end{constructor}
}\label{package-test+u+package+++ml-module-Type-type-variant.C}& foo\\
\ocamlcodefragment{| \begin{constructor}D\end{constructor}
}\label{package-test+u+package+++ml-module-Type-type-variant.D}& \emph{bar}\\
\ocamlcodefragment{| \begin{constructor}E\end{constructor}
 \begin{keyword}of\end{keyword}
 \hyperref[package-test+u+package+++ml-module-Type-type-variant+u+e]{\ocamlinlinecode{variant\_\allowbreak{}e}}}\label{package-test+u+package+++ml-module-Type-type-variant.E}& \\
\end{ocamllongtable}%
}\label{package-test+u+package+++ml-module-Type-type-variant+u+c}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 variant\_\allowbreak{}c = \{}{\setlength{\LTpre}{0pt}\setlength{\LTpost}{0pt}\begin{ocamllongtable}[l]{p{1.000\textwidth}}\ocamlinlinecode{a : int;\allowbreak{}}\label{package-test+u+package+++ml-module-Type-type-variant+u+c.a}\\
\end{ocamllongtable}%
}\ocamlcodefragment{\}}\\
\label{package-test+u+package+++ml-module-Type-type-gadt}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 \_\allowbreak{} gadt = }{\setlength{\LTpre}{0pt}\setlength{\LTpost}{0pt}\begin{ocamllongtable}[l]{p{1.000\textwidth}}\ocamlcodefragment{| \begin{constructor}A\end{constructor}
 : int \hyperref[package-test+u+package+++ml-module-Type-type-gadt]{\ocamlinlinecode{gadt}}}\label{package-test+u+package+++ml-module-Type-type-gadt.A}\\
\ocamlcodefragment{| \begin{constructor}B\end{constructor}
 : int $\rightarrow$ string \hyperref[package-test+u+package+++ml-module-Type-type-gadt]{\ocamlinlinecode{gadt}}}\label{package-test+u+package+++ml-module-Type-type-gadt.B}\\
\ocamlcodefragment{| \begin{constructor}C\end{constructor}
 : \hyperref[package-test+u+package+++ml-module-Type-type-variant+u+c]{\ocamlinlinecode{variant\_\allowbreak{}c}} $\rightarrow$ unit \hyperref[package-test+u+package+++ml-module-Type-type-gadt]{\ocamlinlinecode{gadt}}}\label{package-test+u+package+++ml-module-Type-type-gadt.C}\\
\end{ocamllongtable}%
}\label{package-test+u+package+++ml-module-Type-type-degenerate+u+gadt}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 degenerate\_\allowbreak{}gadt = }{\setlength{\LTpre}{0pt}\setlength{\LTpost}{0pt}\begin{ocamllongtable}[l]{p{1.000\textwidth}}\ocamlcodefragment{| \begin{constructor}A\end{constructor}
 : \hyperref[package-test+u+package+++ml-module-Type-type-degenerate+u+gadt]{\ocamlinlinecode{degenerate\_\allowbreak{}gadt}}}\label{package-test+u+package+++ml-module-Type-type-degenerate+u+gadt.A}\\
\end{ocamllongtable}%
}\label{package-test+u+package+++ml-module-Type-type-private+u+variant}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 private\_\allowbreak{}variant = \begin{keyword}private\end{keyword}
 }{\setlength{\LTpre}{0pt}\setlength{\LTpost}{0pt}\begin{ocamllongtable}[l]{p{1.000\textwidth}}\ocamlcodefragment{| \begin{constructor}A\end{constructor}
}\label{package-test+u+package+++ml-module-Type-type-private+u+variant.A}\\
\end{ocamllongtable}%
}\label{package-test+u+package+++ml-module-Type-type-record}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 record = \{}{\setlength{\LTpre}{0pt}\setlength{\LTpost}{0pt}\begin{ocamllongtable}[l]{p{0.500\textwidth}p{0.500\textwidth}}\ocamlinlinecode{a : int;\allowbreak{}}\label{package-test+u+package+++ml-module-Type-type-record.a}& \\
\ocamlinlinecode{\begin{keyword}mutable\end{keyword}
 b : int;\allowbreak{}}\label{package-test+u+package+++ml-module-Type-type-record.b}& \\
\ocamlinlinecode{c : int;\allowbreak{}}\label{package-test+u+package+++ml-module-Type-type-record.c}& foo\\
\ocamlinlinecode{d : int;\allowbreak{}}\label{package-test+u+package+++ml-module-Type-type-record.d}& \emph{bar}\\
\ocamlinlinecode{e : a.\allowbreak{} \begin{type-var}'a\end{type-var}
;\allowbreak{}}\label{package-test+u+package+++ml-module-Type-type-record.e}& \\
\end{ocamllongtable}%
}\ocamlcodefragment{\}}\\
\label{package-test+u+package+++ml-module-Type-type-polymorphic+u+variant}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 polymorphic\_\allowbreak{}variant = [ }{\setlength{\LTpre}{0pt}\setlength{\LTpost}{0pt}\begin{ocamllongtable}[l]{p{1.000\textwidth}}\ocamlinlinecode{| }\ocamlinlinecode{`A}\label{package-test+u+package+++ml-module-Type-type-polymorphic+u+variant.A}\\
\ocamlinlinecode{| }\ocamlinlinecode{`B \begin{keyword}of\end{keyword}
 int}\label{package-test+u+package+++ml-module-Type-type-polymorphic+u+variant.B}\\
\ocamlinlinecode{| }\ocamlinlinecode{`C \begin{keyword}of\end{keyword}
 int * unit}\label{package-test+u+package+++ml-module-Type-type-polymorphic+u+variant.C}\\
\ocamlinlinecode{| }\ocamlinlinecode{`D}\label{package-test+u+package+++ml-module-Type-type-polymorphic+u+variant.D}\\
\end{ocamllongtable}%
}\ocamlcodefragment{ ]}\\
\label{package-test+u+package+++ml-module-Type-type-polymorphic+u+variant+u+extension}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 polymorphic\_\allowbreak{}variant\_\allowbreak{}extension = [ }{\setlength{\LTpre}{0pt}\setlength{\LTpost}{0pt}\begin{ocamllongtable}[l]{p{1.000\textwidth}}\ocamlinlinecode{| }\ocamlinlinecode{\hyperref[package-test+u+package+++ml-module-Type-type-polymorphic+u+variant]{\ocamlinlinecode{polymorphic\_\allowbreak{}variant}}}\label{package-test+u+package+++ml-module-Type-type-polymorphic+u+variant+u+extension.polymorphic+u+variant}\\
\ocamlinlinecode{| }\ocamlinlinecode{`E}\label{package-test+u+package+++ml-module-Type-type-polymorphic+u+variant+u+extension.E}\\
\end{ocamllongtable}%
}\ocamlcodefragment{ ]}\\
\label{package-test+u+package+++ml-module-Type-type-nested+u+polymorphic+u+variant}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 nested\_\allowbreak{}polymorphic\_\allowbreak{}variant = [ }{\setlength{\LTpre}{0pt}\setlength{\LTpost}{0pt}\begin{ocamllongtable}[l]{p{1.000\textwidth}}\ocamlinlinecode{| }\ocamlinlinecode{`A \begin{keyword}of\end{keyword}
 [ `B | `C ]}\label{package-test+u+package+++ml-module-Type-type-nested+u+polymorphic+u+variant.A}\\
\end{ocamllongtable}%
}\ocamlcodefragment{ ]}\\
\label{package-test+u+package+++ml-module-Type-type-private+u+extenion#row}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 private\_\allowbreak{}extenion\#row}\\
\label{package-test+u+package+++ml-module-Type-type-private+u+extenion}\ocamlcodefragment{\begin{keyword}and\end{keyword}
 private\_\allowbreak{}extenion = \begin{keyword}private\end{keyword}
 [> }{\setlength{\LTpre}{0pt}\setlength{\LTpost}{0pt}\begin{ocamllongtable}[l]{p{1.000\textwidth}}\ocamlinlinecode{| }\ocamlinlinecode{\hyperref[package-test+u+package+++ml-module-Type-type-polymorphic+u+variant]{\ocamlinlinecode{polymorphic\_\allowbreak{}variant}}}\label{package-test+u+package+++ml-module-Type-type-private+u+extenion.polymorphic+u+variant}\\
\end{ocamllongtable}%
}\ocamlcodefragment{ ]}\\
\label{package-test+u+package+++ml-module-Type-type-object+u+}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 object\_\allowbreak{} = < a : int;\allowbreak{} b : int;\allowbreak{} c : int;\allowbreak{} >}\\
\label{package-test+u+package+++ml-module-Type-module-type-X}\ocamlcodefragment{\begin{keyword}module\end{keyword}
 \begin{keyword}type\end{keyword}
 \hyperref[package-test+u+package+++ml-module-Type-module-type-X]{\ocamlinlinecode{X}}}\ocamlcodefragment{ = \begin{keyword}sig\end{keyword}
}\begin{ocamlindent}\label{package-test+u+package+++ml-module-Type-module-type-X-type-t}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 t}\\
\label{package-test+u+package+++ml-module-Type-module-type-X-type-u}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 u}\\
\end{ocamlindent}%
\ocamlcodefragment{\begin{keyword}end\end{keyword}
}\\
\label{package-test+u+package+++ml-module-Type-type-module+u+}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 module\_\allowbreak{} = (\begin{keyword}module\end{keyword}
 \hyperref[package-test+u+package+++ml-module-Type-module-type-X]{\ocamlinlinecode{X}})}\\
\label{package-test+u+package+++ml-module-Type-type-module+u+substitution}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 module\_\allowbreak{}substitution = (\begin{keyword}module\end{keyword}
 \hyperref[package-test+u+package+++ml-module-Type-module-type-X]{\ocamlinlinecode{X}} \begin{keyword}with\end{keyword}
 \begin{keyword}type\end{keyword}
 \hyperref[package-test+u+package+++ml-module-Type-module-type-X-type-t]{\ocamlinlinecode{t}} = int \begin{keyword}and\end{keyword}
 \begin{keyword}type\end{keyword}
 \hyperref[package-test+u+package+++ml-module-Type-module-type-X-type-u]{\ocamlinlinecode{u}} = unit)}\\
\label{package-test+u+package+++ml-module-Type-type-covariant}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 +'a covariant}\\
\label{package-test+u+package+++ml-module-Type-type-contravariant}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 -'a contravariant}\\
\label{package-test+u+package+++ml-module-Type-type-bivariant}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 \_\allowbreak{} bivariant = int}\\
\label{package-test+u+package+++ml-module-Type-type-binary}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 ('a,\allowbreak{} 'b) binary}\\
\label{package-test+u+package+++ml-module-Type-type-using+u+binary}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 using\_\allowbreak{}binary = (int,\allowbreak{} int) \hyperref[package-test+u+package+++ml-module-Type-type-binary]{\ocamlinlinecode{binary}}}\\
\label{package-test+u+package+++ml-module-Type-type-name}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 'custom name}\\
\label{package-test+u+package+++ml-module-Type-type-constrained}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 'a constrained = \begin{type-var}'a\end{type-var}
 \begin{keyword}constraint\end{keyword}
 \begin{type-var}'a\end{type-var}
 = int}\\
\label{package-test+u+package+++ml-module-Type-type-exact+u+variant}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 'a exact\_\allowbreak{}variant = \begin{type-var}'a\end{type-var}
 \begin{keyword}constraint\end{keyword}
 \begin{type-var}'a\end{type-var}
 = [ `A | `B of int ]}\\
\label{package-test+u+package+++ml-module-Type-type-lower+u+variant}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 'a lower\_\allowbreak{}variant = \begin{type-var}'a\end{type-var}
 \begin{keyword}constraint\end{keyword}
 \begin{type-var}'a\end{type-var}
 = [> `A | `B of int ]}\\
\label{package-test+u+package+++ml-module-Type-type-any+u+variant}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 'a any\_\allowbreak{}variant = \begin{type-var}'a\end{type-var}
 \begin{keyword}constraint\end{keyword}
 \begin{type-var}'a\end{type-var}
 = [>  ]}\\
\label{package-test+u+package+++ml-module-Type-type-upper+u+variant}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 'a upper\_\allowbreak{}variant = \begin{type-var}'a\end{type-var}
 \begin{keyword}constraint\end{keyword}
 \begin{type-var}'a\end{type-var}
 = [< `A | `B of int ]}\\
\label{package-test+u+package+++ml-module-Type-type-named+u+variant}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 'a named\_\allowbreak{}variant = \begin{type-var}'a\end{type-var}
 \begin{keyword}constraint\end{keyword}
 \begin{type-var}'a\end{type-var}
 = [< \hyperref[package-test+u+package+++ml-module-Type-type-polymorphic+u+variant]{\ocamlinlinecode{polymorphic\_\allowbreak{}variant}} ]}\\
\label{package-test+u+package+++ml-module-Type-type-exact+u+object}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 'a exact\_\allowbreak{}object = \begin{type-var}'a\end{type-var}
 \begin{keyword}constraint\end{keyword}
 \begin{type-var}'a\end{type-var}
 = < a : int;\allowbreak{} b : int;\allowbreak{} >}\\
\label{package-test+u+package+++ml-module-Type-type-lower+u+object}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 'a lower\_\allowbreak{}object = \begin{type-var}'a\end{type-var}
 \begin{keyword}constraint\end{keyword}
 \begin{type-var}'a\end{type-var}
 = < a : int;\allowbreak{} b : int;\allowbreak{} .\allowbreak{}.\allowbreak{} >}\\
\label{package-test+u+package+++ml-module-Type-type-poly+u+object}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 'a poly\_\allowbreak{}object = \begin{type-var}'a\end{type-var}
 \begin{keyword}constraint\end{keyword}
 \begin{type-var}'a\end{type-var}
 = < a : a.\allowbreak{} \begin{type-var}'a\end{type-var}
;\allowbreak{} >}\\
\label{package-test+u+package+++ml-module-Type-type-double+u+constrained}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 ('a,\allowbreak{} 'b) double\_\allowbreak{}constrained = \begin{type-var}'a\end{type-var}
 * \begin{type-var}'b\end{type-var}
 \begin{keyword}constraint\end{keyword}
 \begin{type-var}'a\end{type-var}
 = int \begin{keyword}constraint\end{keyword}
 \begin{type-var}'b\end{type-var}
 = unit}\\
\label{package-test+u+package+++ml-module-Type-type-as+u+}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 as\_\allowbreak{} = int \begin{keyword}as\end{keyword}
 'a * \begin{type-var}'a\end{type-var}
}\\
\label{package-test+u+package+++ml-module-Type-type-extensible}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 extensible = .\allowbreak{}.\allowbreak{}}\\
\ocamlcodefragment{\begin{keyword}type\end{keyword}
 \hyperref[package-test+u+package+++ml-module-Type-type-extensible]{\ocamlinlinecode{extensible}} += }{\setlength{\LTpre}{0pt}\setlength{\LTpost}{0pt}\begin{ocamllongtable}[l]{p{0.500\textwidth}p{0.500\textwidth}}\ocamlcodefragment{| \begin{extension}Extension\end{extension}
}\label{package-test+u+package+++ml-module-Type-extension-Extension}& Documentation for \hyperref[package-test+u+package+++ml-module-Type-extension-Extension]{\ocamlinlinecode{\ocamlinlinecode{Extension}}[p\pageref*{package-test+u+package+++ml-module-Type-extension-Extension}]}.\\
\ocamlcodefragment{| \begin{extension}Another\_\allowbreak{}extension\end{extension}
}\label{package-test+u+package+++ml-module-Type-extension-Another+u+extension}& Documentation for \hyperref[package-test+u+package+++ml-module-Type-extension-Another+u+extension]{\ocamlinlinecode{\ocamlinlinecode{Another\_\allowbreak{}extension}}[p\pageref*{package-test+u+package+++ml-module-Type-extension-Another+u+extension}]}.\\
\end{ocamllongtable}%
}\label{package-test+u+package+++ml-module-Type-type-mutually}\ocamlcodefragment{\begin{keyword}type\end{keyword}
 mutually = }{\setlength{\LTpre}{0pt}\setlength{\LTpost}{0pt}\begin{ocamllongtable}[l]{p{1.000\textwidth}}\ocamlcodefragment{| \begin{constructor}A\end{constructor}
 \begin{keyword}of\end{keyword}
 \hyperref[package-test+u+package+++ml-module-Type-type-recursive]{\ocamlinlinecode{recursive}}}\label{package-test+u+package+++ml-module-Type-type-mutually.A}\\
\end{ocamllongtable}%
}\label{package-test+u+package+++ml-module-Type-type-recursive}\ocamlcodefragment{\begin{keyword}and\end{keyword}
 recursive = }{\setlength{\LTpre}{0pt}\setlength{\LTpost}{0pt}\begin{ocamllongtable}[l]{p{1.000\textwidth}}\ocamlcodefragment{| \begin{constructor}B\end{constructor}
 \begin{keyword}of\end{keyword}
 \hyperref[package-test+u+package+++ml-module-Type-type-mutually]{\ocamlinlinecode{mutually}}}\label{package-test+u+package+++ml-module-Type-type-recursive.B}\\
\end{ocamllongtable}%
}\label{package-test+u+package+++ml-module-Type-exception-Foo}\ocamlcodefragment{\begin{keyword}exception\end{keyword}
 \begin{exception}Foo\end{exception}
 \begin{keyword}of\end{keyword}
 int * int}\\


